{"ast":null,"code":"import * as wasm from './tic_tac_toe_bg.wasm';\nlet cachegetInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n  if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n    cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n  }\n\n  return cachegetInt32Memory0;\n}\n\nlet cachegetUint32Memory0 = null;\n\nfunction getUint32Memory0() {\n  if (cachegetUint32Memory0 === null || cachegetUint32Memory0.buffer !== wasm.memory.buffer) {\n    cachegetUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n  }\n\n  return cachegetUint32Memory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n  return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n/**\n* @returns {Uint32Array}\n*/\n\n\nexport function initial_state() {\n  try {\n    const retptr = wasm.__wbindgen_export_0.value - 16;\n    wasm.__wbindgen_export_0.value = retptr;\n    wasm.initial_state(retptr);\n    var r0 = getInt32Memory0()[retptr / 4 + 0];\n    var r1 = getInt32Memory0()[retptr / 4 + 1];\n    var v0 = getArrayU32FromWasm0(r0, r1).slice();\n\n    wasm.__wbindgen_free(r0, r1 * 4);\n\n    return v0;\n  } finally {\n    wasm.__wbindgen_export_0.value += 16;\n  }\n}\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArray32ToWasm0(arg, malloc) {\n  const ptr = malloc(arg.length * 4);\n  getUint32Memory0().set(arg, ptr / 4);\n  WASM_VECTOR_LEN = arg.length;\n  return ptr;\n}\n/**\n* @param {Uint32Array} board\n* @returns {number | undefined}\n*/\n\n\nexport function call(board) {\n  try {\n    const retptr = wasm.__wbindgen_export_0.value - 16;\n    wasm.__wbindgen_export_0.value = retptr;\n    var ptr0 = passArray32ToWasm0(board, wasm.__wbindgen_malloc);\n    var len0 = WASM_VECTOR_LEN;\n    wasm.call(retptr, ptr0, len0);\n    var r0 = getInt32Memory0()[retptr / 4 + 0];\n    var r1 = getInt32Memory0()[retptr / 4 + 1];\n    return r0 === 0 ? undefined : r1 >>> 0;\n  } finally {\n    wasm.__wbindgen_export_0.value += 16;\n  }\n}","map":{"version":3,"sources":["/home/nacho/prog/next/tic-tac-toe/pkg/tic_tac_toe_bg.js"],"names":["wasm","cachegetInt32Memory0","getInt32Memory0","buffer","memory","Int32Array","cachegetUint32Memory0","getUint32Memory0","Uint32Array","getArrayU32FromWasm0","ptr","len","subarray","initial_state","retptr","__wbindgen_export_0","value","r0","r1","v0","slice","__wbindgen_free","WASM_VECTOR_LEN","passArray32ToWasm0","arg","malloc","length","set","call","board","ptr0","__wbindgen_malloc","len0","undefined"],"mappings":"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","sourcesContent":["import * as wasm from './tic_tac_toe_bg.wasm';\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nlet cachegetUint32Memory0 = null;\nfunction getUint32Memory0() {\n    if (cachegetUint32Memory0 === null || cachegetUint32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachegetUint32Memory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n/**\n* @returns {Uint32Array}\n*/\nexport function initial_state() {\n    try {\n        const retptr = wasm.__wbindgen_export_0.value - 16;\n        wasm.__wbindgen_export_0.value = retptr;\n        wasm.initial_state(retptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var v0 = getArrayU32FromWasm0(r0, r1).slice();\n        wasm.__wbindgen_free(r0, r1 * 4);\n        return v0;\n    } finally {\n        wasm.__wbindgen_export_0.value += 16;\n    }\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4);\n    getUint32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n* @param {Uint32Array} board\n* @returns {number | undefined}\n*/\nexport function call(board) {\n    try {\n        const retptr = wasm.__wbindgen_export_0.value - 16;\n        wasm.__wbindgen_export_0.value = retptr;\n        var ptr0 = passArray32ToWasm0(board, wasm.__wbindgen_malloc);\n        var len0 = WASM_VECTOR_LEN;\n        wasm.call(retptr, ptr0, len0);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return r0 === 0 ? undefined : r1 >>> 0;\n    } finally {\n        wasm.__wbindgen_export_0.value += 16;\n    }\n}\n\n"]},"metadata":{},"sourceType":"module"}